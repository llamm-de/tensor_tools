module test_solvers
    use funit
    use libtt_precision    ,        only: dp
    use libtt_solvers_gauss,        only: gauss
    use libtt_solvers_eigenproblem, only: powerMethod

    implicit none

    real(kind=dp), dimension(3,3) :: A
    real(kind=dp), dimension(3)   :: b

contains

    @before
    subroutine set_up()
        b = (/3, 3, 10/)
        A = reshape((/1, 3, 2, 2, 4, 10, 1, 0, 4/),&
                    (/3,3/))
    end subroutine set_up

    @test
    subroutine assert_gauss_result()

        call gauss(A, b)
        @assertEqual((/1, 0, 2/), b)

    end subroutine assert_gauss_result

    @test
    subroutine assert_gauss_matrix()
        real(kind=dp), dimension(3,3) :: expected_result

        expected_result = reshape((/3.0, 0.0, 0.0, 4.0, 22.0/3.0, 0.0, 0.0, 4.0, 7.0/11.0/),(/3,3/))
        call gauss(A)
        @assertEqual(expected_result, A, tolerance=1.0d-5)

    end subroutine assert_gauss_matrix

    @test
    subroutine assert_powerMethod_vector()
        real(kind=dp), dimension(3) :: expected_result
        real(kind=dp)               :: eigVal

        expected_result = (/0.23570226, 0.23570226, 0.94280904/)
        b = (/1,1,1/)
        call powerMethod(A, b, eigVal)

        @assertEqual(expected_result, b, tolerance=1.0d-5)
    end subroutine assert_powerMethod_vector

    @test
    subroutine assert_powerMethod_value()
        real(kind=dp) :: expected_result
        real(kind=dp) :: eigVal

        expected_result = 7.0d0
        b = (/1,1,1/)
        call powerMethod(A, b, eigVal)

        @assertEqual(expected_result, eigVal, tolerance=1.0d-5)
    end subroutine assert_powerMethod_value

end module test_solvers